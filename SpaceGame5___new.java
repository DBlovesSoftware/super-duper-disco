/* autogenerated by Processing revision 1293 on 2024-02-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class SpaceGame5___new extends PApplet {

Blackhole blackhole; // global variables for blackhole
Earth earth; // global variables for earth
Spaceship spaceship; // global variables for spaceship
Astronaut astronaut; // global variables for astronaut
Spacestation spacestation; // global variables for spacestation
HomePage homePage; // global variables for homepage
RulesPage rulesPage; // global variables for rulespage
EndPage endPage; // global variables for endpage

PImage backGround; //using PImage to call an image
int bgX = 0; //bgX - background frame rate
int score = 0; // variable for recorded score

// variables to represent state of the game
final int HOMEPAGE = 0; //constant variable for homepage
final int PLAYING = 1; //constant variable for game
final int RULESPAGE = 2; // constant variable for rules
final int GAMEOVER = 3; // constant variable for endpage
int gameMode = HOMEPAGE; // sets initiable page to gamemode


int currentPage;
int startTime;
int currentLevel = 1;
int highScore = 0;
int newHighScore = 0;
int initialTime = 20000; // Initial time in milliseconds
int timeDecreaseRate = 3000; // Time decreases by  second per level
boolean timerActive = false;

//array list create multiple instances of the draggable objects
ArrayList<Asteroid> asteroidList = new ArrayList<>(); //array list for asteroids
ArrayList<Spaceship> spaceshipList = new ArrayList<>();//array list for asteroids
ArrayList<Astronaut> astronautList = new ArrayList<>();//array list for asteroids
ArrayList<Astronaut> astronautsToRemove = new ArrayList<>();//array list for to respawn asteroids removed
ArrayList<Spaceship> spaceshipsToRemove = new ArrayList<>();  //array list for to respawn spaceships when removed

public void setup() {
  /* size commented out by preprocessor */; //size of canvas (can be changed)
  initializePages(); //when pages are called
  initializeGameElements(); //when objects are respawned for next level
  setupGame(); //to reset timer for next level
  loadObjects(); // to display objects on page
  loadBackgroundImage(); // to display the game background
  initializeHighScore(); // to diplsay the high score
  String[] lines = loadStrings("highscore.txt"); // highscore saved in text file
if (lines.length > 0) {
  highScore = Integer.parseInt(lines[0]);
} else {
  // Handle the case where the file is empty or not present
  highScore = 0;
}
  
}

public void draw() {
  
  if (currentPage == HOMEPAGE) { //if statement to display homepage
    homePage.display();
  } else if (currentPage == RULESPAGE) { //else if statement to rulespage 
    rulesPage.display();
  } else if (currentPage == PLAYING) {
    if (timerActive && millis() - startTime >= initialTime) {
      timerActive = true;  //else if statement to display gameover page when timer has run out
      currentPage = GAMEOVER;
      

      
    }
    if(currentPage == GAMEOVER) {
      currentPage = endPage.handleButtonClicks(); //when gameover page over, this is for the button logic
      endPage.display(score);
    }
    
  else {
      drawBackground();
      //countdown for game
      int remainingTime = max(0, (initialTime - (millis() - startTime) - (currentLevel - 1) * timeDecreaseRate) / 1000);
      //when timer = 0, game will call gameover page
      if (remainingTime == 0) {
        endPage.display(score);
       
      }
      // text to show timer for the game
      textSize(20);
      fill(255);
      textAlign(LEFT, TOP);
      text("Time: " + remainingTime + " seconds", 10, 10);


      // Update and render asteroids, check collisions with spaceship and astronaut
  for (Asteroid asteroid : asteroidList) {
    asteroid.update();
    asteroid.render();
    if (spaceship.checkCollision(asteroid)) {
      spaceship.handleCollision(asteroid);
    }
    if (astronaut.checkCollision(asteroid)) {
      astronaut.handleCollision(asteroid);
    }
  }

  // Update and check collisions for spaceships
  for (Spaceship spaceship : spaceshipList) {
    spaceship.update();
    for (Asteroid asteroid : asteroidList) {
      if (spaceship.checkCollision(asteroid)) {
        spaceship.handleCollision(asteroid);
      }
    }
  }

  // Update, render, and check collisions for astronauts
  for (Astronaut astronaut : astronautList) {
    astronaut.update();
    astronaut.render();
    for (Asteroid asteroid : asteroidList) {
      if (astronaut.checkCollision(asteroid)) {
        astronaut.handleCollision(asteroid);
      }
    }
    // Check collision with space station, update score, and add astronaut to removal list
    if (spacestation.checkCollision(astronaut)) {
      astronaut.handleCollision(spacestation);
      score += 10;
      astronautsToRemove.add(astronaut);
    }
  }

  // Update, check collisions, and handle removal for spaceships
  for (Spaceship spaceship : spaceshipList) {
    spaceship.update();
    for (Asteroid asteroid : asteroidList) {
      if (spaceship.checkCollision(asteroid)) {
        spaceship.handleCollision(asteroid);
      }
    }
    // Check collision with space station, update score, and add spaceship to removal list
    if (spacestation.checkCollision(spaceship)) {
      spaceship.handleCollision(spacestation);
      score += 10;
      spaceshipsToRemove.add(spaceship);
    }
  }

  // If no astronauts, spaceships, and asteroids left, progress to the next level
  if (astronautList.isEmpty() && spaceshipList.isEmpty() && asteroidList.isEmpty()) {
    currentLevel++;
    startTime = millis() - (currentLevel - 1) * timeDecreaseRate;
    initialTime = 20000;
  }

  // Update black hole, earth, and space station
  blackhole.update();
  earth.update();
  spacestation.update();

  // Check collisions and update score for asteroids near black hole
  for (int j = asteroidList.size() - 1; j >= 0; j--) {
    Asteroid currentAsteroid = asteroidList.get(j);
    currentAsteroid.update();
    if (blackhole.checkCollision(currentAsteroid)) {
      score += 10;
      asteroidList.remove(j);
    }
  }

  // Check collisions with space station and update score for spaceships
  for (int k = spaceshipList.size() - 1; k >= 0; k--) {
    Spaceship currentSpaceship = spaceshipList.get(k);
    currentSpaceship.update();
    if (spacestation.checkCollision(currentSpaceship)) {
      score += 10;
      spaceshipList.remove(k);
      spaceshipsToRemove.add(currentSpaceship);
    }
  }

  // Check collisions with space station and update score for astronauts
  for (int l = astronautList.size() - 1; l >= 0; l--) {
    Astronaut currentAstronaut = astronautList.get(l);
    currentAstronaut.update();
    if (spacestation.checkCollision(currentAstronaut)) {
      score += 10;
      astronautList.remove(l);
      astronautsToRemove.add(currentAstronaut);
    }
  }

  // Remove astronauts and spaceships marked for removal
  for (Astronaut astronaut : astronautsToRemove) {
    astronautList.remove(astronaut);
  }

  for (Spaceship spaceship : spaceshipsToRemove) {
    spaceshipList.remove(spaceship);
  }

  astronautsToRemove.clear();
  spaceshipsToRemove.clear();

  // Remove black hole if no asteroids are left
  if (asteroidList.isEmpty()) {
    blackhole.removed();
  }

  // Remove space station if no spaceships are left
  if (spaceshipList.isEmpty()) {
    spacestation.removed();
  }

  // Remove space station if no astronauts are left
  if (astronautList.isEmpty()) {
    spacestation.removed();
  }
  displayHighScore();
}
}

// Check if game over conditions are met based on the current level, astronauts, spaceships, and asteroids
if (currentLevel <= 3 && astronautList.isEmpty() && spaceshipList.isEmpty() && asteroidList.isEmpty()) {
  currentPage = GAMEOVER;
  timerActive = false;
  endPage.display(score);
} else if (currentLevel > 3 && astronautList.isEmpty() && !spaceshipList.isEmpty() && !asteroidList.isEmpty()) {
  currentPage = GAMEOVER;
  timerActive = false;

  // If the score is higher than the high score, update the high score
  if (score > highScore) {
    highScore = score;
    saveHighScore(highScore);
  }
}
}

// Display the high score on the screen
public void displayHighScore() {
  textSize(20);
  fill(255);
  textAlign(CENTER, TOP);
  text("High Score: " + highScore, width / 2, 10);
}

// Save the new high score to a file
public void saveHighScore(int newHighScore) {
  MySQLHandler.insertHighScore("daniel", newHighScore);
  String[] lines = { str(newHighScore) };
  saveStrings("highscore.txt", lines);
}

// Load the high score from a file
public int loadHighScore() {
  String[] data = loadStrings("highscore.txt");
  if (data.length > 0) {
    return PApplet.parseInt(data[0]);
  } else {
    return 0; // Return 0 if there's no high score saved
  }
}

// Handles mouse clicks based on the current game page
public void mousePressed() {
  if (currentPage == HOMEPAGE) {
    currentPage = homePage.handleButtonClicks();
    if (currentPage == PLAYING) {
      timerActive = true;
      startTime = millis();
    }
  } else if (currentPage == RULESPAGE) {
    currentPage = rulesPage.handleButtonClicks();
  } else if (currentPage == GAMEOVER) {
    currentPage = endPage.handleButtonClicks();
  }
}
//calling the different pages
public void initializePages() {
  homePage = new HomePage();
  rulesPage = new RulesPage();
  currentPage = HOMEPAGE;
  endPage = new EndPage();
}
//continues renders background image
public void drawBackground() {
  image(backGround, 0, bgX);
  image(backGround, 0, bgX + backGround.height);

  bgX -= 1;
  if (bgX <= -backGround.height) {
    bgX = 0;
  }
}
// to load background image using png
//sizes backgroundimage to full canvas size
public void loadBackgroundImage() {
  backGround = loadImage("spacebackground.png");
  backGround.resize(width, height);
}
// x, y for objects
public void loadObjects() {
  blackhole = new Blackhole(0, 5);
  spacestation = new Spacestation(0, 3);
  earth = new Earth(10, 15);
  astronaut = new Astronaut(0, 3);
  spaceship = new Spaceship(0, 3);
}

public void setupGame() {
  startTime = millis();  // Reset timer and initial time
  initialTime = 20000;  
}


public void resetGameForNextLevel() {
  // Reset game elements based on the current level
  initializeGameElements();

  
  
}
public void initializeHighScore() {
  highScore = loadHighScore(); // sets highscore on screen to newest highscore
}

public void initializeGameElements() {
  // Initialize game elements based on the current level
  asteroidList.clear();
  spaceshipList.clear();
  astronautList.clear();
  
  // Only create asteroids in the first level
  if (currentLevel == 1) {
    for (int i = 0; i < 4; i++) {
      int randomA = (int) random(0, width);
      int randomB = (int) random(0, height - 300);
      asteroidList.add(new Asteroid(randomA, randomB));
    }
  }

  // Add spaceships and astronauts in subsequent levels
  if (currentLevel > 1) {
    for (int m = 0; m < 2; m++) {
      int randomX = (int) random(0, width);
      int randomY = (int) random(0, height);
      astronautList.add(new Astronaut(randomX, randomY));
    }
  }

  if (currentLevel > 2) {
    for (int m = 0; m < 2; m++) {
      int randomX = (int) random(0, width);
      int randomY = (int) random(0, height);
      spaceshipList.add(new Spaceship(randomX, randomY));
    }
  }
}

  class MySQLHandler {
    private static final String JDBC_URL = "jdbc:mysql://your_mysql_server:3306/game_database";
    private static final String USER = "your_username";
    private static final String PASSWORD = "your_password";

    public static void insertHighScore(String playerName, int score) {
      try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD)) {
        String insertQuery = "INSERT INTO highscores (name, score) VALUES (?, ?)";
        try (PreparedStatement preparedStatement = connection.prepareStatement(insertQuery)) {
          preparedStatement.setString(1, playerName);
          preparedStatement.setInt(2, score);
          preparedStatement.executeUpdate();
        }
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }

    public static void displayHighScores() {
      try (Connection connection = DriverManager.getConnection(JDBC_URL, USER, PASSWORD)) {
        String selectQuery = "SELECT name, score FROM highscores ORDER BY score DESC LIMIT 10";
        try (PreparedStatement preparedStatement = connection.prepareStatement(selectQuery);
             ResultSet resultSet = preparedStatement.executeQuery()) {
          while (resultSet.next()) {
            String playerName = resultSet.getString("name");
            int score = resultSet.getInt("score");
            System.out.println("Player: " + playerName + ", Score: " + score);
          }
        }
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }
  }
//Class Inheritance
class Asteroid extends Floater {
  //Constructor - x, y
  Asteroid(int x, int y) {
    super(x, y, new String[]{"asteroid1.png", "asteroid2.png", "asteroid3.png", "asteroid4.png"},0);
  }
   
 
  
   // sets movement logic across vertical distance of height.
  // Asteroid respawns when asteroids y-coordinate > height
  public void move() {
    // yspeed of asteroid is 0 as they are stationary
    y -= random(-1, 0);
    if (y > height) {
      y = 0;
    }
  }
}
//Class Inheritance
class Astronaut extends Floater {
  //Constructor - x, y
  Astronaut(int x, int y) {
    super(x, y, new String[]{"astronaut1.png"},0);
    
  }
// sets movement logic across vertical distance of height.
  // Astronaut respawns when astronauts y-coordinate > height
  public void move() {
    y -= random(-1.6f,-0.2f);
    if (y > height) {
      y = 0;
    }
  }
}
  
class Blackhole extends Floater {
  boolean isActive;

  Blackhole(int x, int initialSpeed) {
    super(x, height - 165, new String[]{"blackhole1.png", "blackhole2.png", "blackhole3.png", "blackhole4.png"}, initialSpeed);
    isActive = true;
  }

  // Resets the blackhole to its initial state
  public void reset() {
    isActive = true;
    x = 0;
  }

  // Moves the blackhole across the bottom of the screen
  // Respawns when x-coordinate > width
  public void move() {
    if (isActive) {
      x += xspeed;
      if (x > width) {
        respawn();
      }
    }
  }

  // Checks collision with an asteroid
  // Returns true if a collision occurs, otherwise false
  public boolean checkCollision(Asteroid asteroid) {
    if (!isActive) {
      return false;
    }
    float distance = dist(x, y, asteroid.x, asteroid.y);
    return distance < (images[0].width + asteroid.wide) / 4;
  }

  // Deactivates the blackhole
  public void removed() {
    isActive = false;
  }

  // Renders the blackhole if it's active
  public void render() {
    if (isActive) {
      super.render();
    }
  }

  // Respawns the blackhole to the initial position
  private void respawn() {
    x = -images[0].width;
    println("Respawned");
  }
}
class Button {
  float x, y, w, h;
  String label;
  int baseColor, hoverColor, currentColor, textColor;
  float baseTextSize, hoverTextSize;

  // Constructor for the Button class
  Button(float x, float y, float w, float h, String label) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.label = label;
    this.baseColor = color(30, 144, 255);
    this.hoverColor = color(70, 184, 255);
    this.currentColor = baseColor;
    this.textColor = color(255);
    this.baseTextSize = 20;
    this.hoverTextSize = 24;
  }

  // Display method to render the button on the screen
  public void display() {
    rectMode(CENTER);
    fill(currentColor);
    rect(x, y, w, h);

    textAlign(CENTER, CENTER);
    textSize(baseTextSize);
    fill(textColor);
    text(label, x, y);
  }

  // Check if the mouse is hovering over the button
  public boolean isHovered(float mx, float my) {
    return mx > x - w / 2 && mx < x + w / 2 && my > y - h / 2 && my < y + h / 2;
  }

  // Handle the button hover state
  public void hover() {
    currentColor = hoverColor;
    textSize(hoverTextSize);
  }

  // Reset the button to its default state
  public void reset() {
    currentColor = baseColor;
    textSize(baseTextSize);
  }

  // Check if the button is clicked
  public boolean isClicked(float mx, float my) {
    return isHovered(mx, my);
  }

  // Handle the button click action
  public void onClick() {
    // Perform different actions based on the button label
    if (label.equals("Exit")) {
      exit(); // Exit the application if the button is labeled "Exit"
    } else if (label.equals("Next Level")) {
      handleNextLevelClick(); // Handle the next level click action
    }
    
  }

  // Private method to handle the "Next Level" button click
  private void handleNextLevelClick() {
    currentLevel++;
    score = 0;
    startTime = millis();
  }
}
//Class Inheritance

class Earth extends Floater {
  //Constructor - x, y
Earth(int x, int y) {
    super(x, y, new String[]{"earth1.png", "earth2.png", "earth3.png", "earth4.png"},0);
  }
}
class EndPage {
  String endMessage = "Game Over!"; // message on gameover page
  String scoreMessage = "Your final score: "; // message on gameover page
  int finalScore;
  boolean nextLevelButtonVisible = true;
  //int nextLevelButtonClickCount = 0;

  Button exitButton, nextLevelButton; //calling button logic from button class

  EndPage() {
    exitButton = new Button(width / 2 - 80, height / 2 + 100, 150, 70, "Exit"); // coordinates to display button
    nextLevelButton = new Button(width / 2 + 80, height / 2 + 100, 150, 70, "Next Level"); // coordinates to display button
  }

  public void display(int finalScore) {
    this.finalScore = finalScore;
    background(0); //black background for gameover page
    if (nextLevelButtonVisible) {
      nextLevelButton = new Button(width / 2 + 80, height / 2 + 100, 150, 70, "Next Level");
    }

    textSize(40); // textsize
    fill(255); // White text
    textAlign(CENTER, CENTER); // alligns score in middle
    text(endMessage, width / 2, height / 2 - 50); // coordinates for end message 

    textSize(30);
    text(scoreMessage + finalScore, width / 2, height / 2 + 50); // coordinates for final score

    exitButton.display(); //displays exit button
    nextLevelButton.display();    //displays next level button
    handleButtonHover(exitButton); // when mouse hovers over button, button luminates
    handleButtonHover(nextLevelButton);// when mouse hovers over button, button luminates

  }

 public int handleButtonClicks() {
  switch (currentPage) { //switch case
    case PLAYING: // when next level button is clicked, it goes to resetGameForNextLevel();
      if (nextLevelButton.isClicked(mouseX, mouseY)) {
        handleNextLevelButtonClick();
        return PLAYING; //returns to game where objects are reset
      }
      break; // if buttons not pressed stop game

    case GAMEOVER:
      if (nextLevelButton.isClicked(mouseX, mouseY)) {
        resetGameForNextLevel(); // when next level button is clicked, it goes to resetGameForNextLevel();
        return PLAYING;
      } else if (exitButton.isClicked(mouseX, mouseY)) {
        exit(); //if user wants to exit, press exit button or 'esc'
      }
      break; //if buttons not pressed stop game


    default://if buttons not pressed stop game
      break;
  }
  return GAMEOVER; // stays on gameover page if no buttons pressed
}

  public void handleNextLevelButtonClick() {
     // when next level button is clicked, it goes to resetGameForNextLevel();
    resetGameForNextLevel();
  }

  public void handleButtonHover(Button button) {
    if (button.isHovered(mouseX, mouseY)) {
      button.hover(); // handles the mouse logic when mouse is ontop of buttons
    } else {
      button.reset();
    }
  }

  public void resetGameForNextLevel() {
    for (Floater asteroid : asteroidList) {
      asteroid.x = (int) random(0, width); // resets asteroids for next level
      asteroid.y = (int) random(0, height - 300);
    }

    for (Floater spaceship : spaceshipList) {
      spaceship.x = (int) random(0, width); // resets spaceships for next level
      spaceship.y = (int) random(0, height);
    }

    for (Floater astronaut : astronautList) {
      astronaut.x = (int) random(0, width); // resets astronauts for next level
      astronaut.y = (int) random(0, height);
    }

    spacestation.x = 0;
    spacestation.y = height - 365;

    blackhole.x = 0;
    blackhole.y = height - 165;

    earth.x = 10;
    earth.y = 15;

    currentPage = PLAYING;

    if (astronautList.isEmpty() && spaceshipList.isEmpty() && asteroidList.isEmpty()) {
      currentLevel++;
      startTime = millis() - (currentLevel - 1) * timeDecreaseRate;
      blackhole.reset();  // logic for when level has been completed, current level increases so timer restarts
      if (currentLevel > 1) {
        timerActive = true;
      }
    }

    int additionalAstronauts = 2 * currentLevel; // increases no. of astronauts for next level
    int additionalSpaceships = 2 * currentLevel; // increases no. of spaceships for next level
    int additionalAsteroids = 2 * currentLevel;// increases no. of asteroids for next level

    for (int i = 0; i < additionalAstronauts; i++) {
      astronautList.add(new Astronaut((int) random(0, width), (int) random(0, height))); 
    } //positon for astronauts to drop from
    

    for (int i = 0; i < additionalSpaceships; i++) {
      spaceshipList.add(new Spaceship((int) random(0, width), (int) random(0, height)));
    }

    for (int i = 0; i < additionalAsteroids; i++) {
      asteroidList.add(new Asteroid((int) random(0, width), (int) random(0, height - 300)));
    }
  }


}
class Floater {
  float wide = 200; // Width of the floater
  float dx, dy; // Variables for the change in x and y
  int clickX, clickY, x, y, xspeed, imgCounter, xPos, yPos, initialSpeed, localmouseX, localmouseY; // Various integer variables
  PImage[] images; // Array to store images
  boolean hold; // Boolean variable to track if the floater is being held/dragged

  // Constructor method
  Floater(int x, int y, String[] imageNames, int initialSpeed) {
    this.x = x;
    this.y = y;
    this.xspeed = initialSpeed;
    this.hold = false;
    this.imgCounter = 0;
    this.localmouseX = 0;
    this.localmouseY = 0;

    // Initialize the array of PImages
    images = new PImage[imageNames.length];
    for (int i = 0; i < imageNames.length; i++) {
      images[i] = loadImage(imageNames[i]);
    }
  }

  // Method to update mouse position
  public void updateMouse() {
    localmouseX = mouseX;
    localmouseY = mouseY;
  }

  // Main update method
  public void update() {
    render(); // Render the floater
    checkDrag(); // Check if the floater is being dragged
    move(); // Move the floater
    updateMouse(); // Update mouse position
  }

  // Placeholder method for moving logic
  public void move() {
    // Your move logic goes here
  }

  // Render the floater
  public void render() {
    image(images[imgCounter / 10 % images.length], x, y); // Display the current image
    imgCounter++;
  }

  // Check if the floater is being dragged
  public void checkDrag() {
    float d = dist(localmouseX, localmouseY, x, y); // Calculate distance between mouse and floater
    if (!(this instanceof Blackhole) && !(this instanceof Spacestation) && !(this instanceof Earth)) {
      if (d < wide / 4 && d > -wide / 4) { //'this instanceof' used to test if object is an instance of a particular class
        if (mousePressed) {
          if (!hold) {
            hold = true; // When the mouse is held, objects can then be dragged
            clickX = localmouseX - x;
            clickY = localmouseY - y;
          }
        } else {
          hold = false; // If the mouse is not held, objects will not be dragged
        }
      }
    }
  //if held , objects will be dragged
    if (hold) {
      x = localmouseX - clickX;
      y = localmouseY - clickY;
    }
  }

  // Check if two floaters are colliding
  public boolean checkCollision(Floater other) {
    float d = dist(x, y, other.x, other.y); // Calculate distance between this floater and another
    float minDist = wide / 6 + other.wide / 6; // Minimum distance for a collision
    return d < minDist;
  }

  // Handle collision between two floaters
  public void handleCollision(Floater other) {
    float angle = atan2(other.y - y, other.x - x); // Calculate angle between floaters
    float moveAmount = (wide / 3 + other.wide / 3) / 2.0f; // Calculate movement amount
    x -= cos(angle) * moveAmount; // Move in the x direction
    y -= sin(angle) * moveAmount; // Move in the y direction
    xPos = other.x; // Record the x position of the other floater
    yPos = other.y; // Record the y position of the other floater
  }
}
class HomePage {
  int numStars = 100; // Number of stars in the background
  Star[] stars = new Star[numStars]; // Array to store Star objects

  Button playButton, rulesButton, exitButton, nextLevelButton; // Buttons for different actions
  RulesPage rulesPage; // RulesPage object

  // Constructor method for HomePage
  HomePage() {
    // Initialize buttons and RulesPage
    playButton = new Button(width / 2, 200, 150, 70, "Play");
    rulesButton = new Button(width / 2, 300, 150, 70, "How to play");
    exitButton = new Button(width / 2, 400, 150, 70, "Exit");
    nextLevelButton = new Button(width / 2, 500, 150, 70, "Next Level");
    rulesPage = new RulesPage();

    // Initialize stars array with random Star objects
    for (int i = 0; i < numStars; i++) {
      stars[i] = new Star(random(width), random(height));
    }
  }

  // Method to handle button clicks and change game mode
  public int handleButtonClicks() {
    if (currentPage == HOMEPAGE) {
      if (playButton.isClicked(mouseX, mouseY)) {
        return PLAYING;
      } else if (rulesButton.isClicked(mouseX, mouseY)) {
        return RULESPAGE;
      } else if (exitButton.isClicked(mouseX, mouseY)) {
        exitButton.onClick();
      } else if (nextLevelButton.isClicked(mouseX, mouseY)) {
        endPage.resetGameForNextLevel();
        nextLevel();
        return PLAYING;
      }

      return PLAYING;
    }

    return HOMEPAGE;
  }

  // Method to display the home page
  public void display() {
    background(0);

    // Display stars in the background
    for (int i = 0; i < numStars; i++) {
      stars[i].floatAround();
      stars[i].followMouse(mouseX, mouseY);
      stars[i].display();
    }
    //Centering game title
    textAlign(CENTER, CENTER);
    textSize(50);
    fill(120);
    text("Galactic Drift", width / 2, 100);

    // Display buttons based on the current game page
    if (currentPage == HOMEPAGE) {
      playButton.display();
      rulesButton.display();
      exitButton.display();

      // Handle button hover effects
      handleButtonHover(playButton);
      handleButtonHover(rulesButton);
      handleButtonHover(exitButton);
    } else if (currentPage == RULESPAGE) {
      rulesPage.display();
    }
  }

  // Method to handle mouse clicks using switch case
  public void mousePressed() {
    switch (gameMode) {
      case HOMEPAGE:
        currentPage = handleButtonClicks();
        break;

      case PLAYING:
        timerActive = false;
        startTime = millis();
        break;

      case RULESPAGE:
        currentPage = rulesPage.handleButtonClicks();
        break;

      case GAMEOVER:
        currentPage = endPage.handleButtonClicks();
        break;

      // Add a default case if needed
      default:
        // Handle the case when gameMode is not any of the specified cases
        break;
    }
  }

  // Method to handle button hover effects
  public void handleButtonHover(Button button) {
    if (button.isHovered(mouseX, mouseY)) {
      button.hover();
    } else {
      button.reset();
    }
  }

  // Method to progress to the next game level
  public void nextLevel() {
    currentLevel++;
    score = 0;
    startTime = millis();
  }
}
class RulesPage {
  Button backButton; // Button to navigate back to the home page
  PImage background; // Background image for the rules page

  // Constructor for initializing the rules page with background image and back button
  RulesPage() {
    background = loadImage("spacebackground.png"); // Load background image
    backButton = new Button(width / 2, height - 50, 150, 50, "Back to Home"); // Create a back button centered at the bottom
  }

  // Display method to show the rules page content
  public void display() {
    background(0); // Set background color

    // Display rules content using the background image
    imageMode(CORNER);
    image(background, 0, 0, width, height); // Display background image
    displayRulesText(); // Display the rules text

    backButton.display(); // Display the back button
    handleButtonHover(backButton); // Handle hover effects for the back button
  }

  // Display method for showing the rules text
  public void displayRulesText() {
    textAlign(CENTER, CENTER);
    textSize(24);
    fill(255, 255, 0); // Set text color to yellow
    text("Rules:", width / 2, height / 3); // Display the title

    // Display individual rules with explanations
    text("-   Hover over while clicked and held to drag items", width / 2, height - 450);
    text("-   Collect all asteroids into the black hole to make it disappear and slow down other objects", width / 2, height - 400);
    text("-   Collect all astronauts/spaceships into the top left corner of the space station before the timer runs out to win", width / 2, height - 350);
    text("-   If you lose, images may still render for 5 seconds", width / 2, height - 300);
    text("-   Use 'Esc' to exit from the game", width / 2, height - 250);
    text("-   Easy enough? LET'S PLAY !! ↓", width / 2, height - 200);
  }

  // Method to handle button clicks and determine the next page
  public int handleButtonClicks() {
    switch (RULESPAGE) {
      case RULESPAGE: // Check if the current page is the rules page
        if (backButton.isClicked(mouseX, mouseY)) {
          return HOMEPAGE; // Return to the home page if the back button is clicked
        }
        break;
    }
    return RULESPAGE; // Return the current page if no button is clicked
  }

  // Method to handle button hover effects
  public void handleButtonHover(Button button) {
    if (button.isHovered(mouseX, mouseY)) {
      button.hover(); // Hover effect when the mouse is over the button
    } else {
      button.reset(); // Reset the button to its default state
    }
  }
}
class Spaceship extends Floater {
  //Constructor Method for spaceships
  Spaceship(int x, int y) {
    super(x, y, new String[]{"spaceship1.png"},0);
  }
   public void move() {
    y -= random(-1.2f, 0);
    // if asteroid goes off screen, reset the x to width
    if (y > height) {
      y = 0;
    }
  }
}

//Class Inheritance
class Spacestation extends Floater {
  boolean isActive; //boolean for when objects are moving
  
// Constructor - x, initialSpeed
  Spacestation(int x, int initialSpeed) {
    super(x, height-365, new String[]{"spacestation1.png"}, initialSpeed);
    
    isActive = true; // Set the space station to active initially
  }
  

  // sets movement logic across bottom of width.
  // Spacestation respawns when spacestation x-coordinate > width
  public void move() {
    x += xspeed;
    if (x > width) {
      x = -images[0].width;
      println("Respawned");
    }
  }

  // Checks collision with Astronaut
  public boolean checkAstronautCollision(Astronaut astronaut) {
    if (!isActive) {
      return false;
    }
    float distance = dist(x, y, astronaut.x, astronaut.y);
    return distance < (images[0].width + astronaut.wide) / 4;
  }

  // Checks collision with Spaceship
  public boolean checkSpaceshipCollision(Spaceship spaceship) {
    if (!isActive) {
      return false;
    }
    float distance = dist(x, y, spaceship.x, spaceship.y);
    return distance < (images[0].width + spaceship.wide) / 4;
  }
  // if objects still active when timer = 0, isActive is true and set the isEmpty() off.
  public void removed() {
    isActive = true;
  }
// Renders the spacestation if it's active
  public void render() {
    if (isActive) {
      super.render();
    }
  }
}
class Star {
  PImage sparkleImage;
  float x, y, movingX, movingY;
  float speed = 2;
  int starColor;
  //Constructor method for star class
  Star(float x, float y) {
    sparkleImage = loadImage("sparkle.png");
    this.x = x;
    this.y = y;
    starColor = color(random(200, 255), random(200, 255), random(200, 255));
    movingX = random(0, 1000);
    movingY = random(0, 1000);
  }

  public void floatAround() {
    float moveX = noise(movingX); //noise() returns the value between 0 and 1 (creates smooth motion)
    float moveY = noise(movingY);

    x += map(moveX, 0, 1, -speed, speed); //move() remaps value from one range to another
    y += map(moveY, 0, 1, -speed, speed);
   
  }
    public void followMouse(float targetX, float targetY) {
    float angle = atan2(targetY - y, targetX - x); //atan2() returns angle in radians betwwen positive x-axis and point of x,y
    x += cos(angle) * speed; //cos()returns cosine of angle given in radians
    y += sin(angle) * speed; //sin()returns cosine of angle given in radians
  }
  //displays the image with coordinates and size
  public void display() {
    image(sparkleImage, x, y, 50, 50);
  }
}


  public void settings() { size(1000, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SpaceGame5___new" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
